### THIS FILE IS AUTOGENERATED. DO NOT EDIT THIS FILE DIRECTLY ###
from . import data_pb2_grpc
import data_pb2
from .data_pb2 import *
from minknow.rpc._support import MessageWrapper, ArgumentError

__all__ = [
    "DataService",
    "GetDataTypesRequest",
    "GetDataTypesResponse",
    "GetSignalBytesRequest",
    "GetSignalBytesResponse",
    "GetSignalMinMaxBytesRequest",
    "GetSignalMinMaxBytesResponse",
    "GetLiveReadsRequest",
    "GetLiveReadsResponse",
]

class DataService(object):
    def __init__(self, channel):
        self._stub = DataServiceStub(channel)
        self._pb = data_pb2

    def get_data_types(self, message=None, **kwargs):
        """
        Get the data types of data items produced by this service.

        In order to allow clients to efficiently deal with large volumes of data in languages such as
        Python, this service can provide data as raw bytes. This call can be used to determine how to
        interpret those bytes. This can be used to construct an appropriate numpy dtype, for example.

        :rtype: GetDataTypesResponse
        """
        if message is not None:
            return MessageWrapper(self._stub.get_data_types(message), unwraps=[])

        unused_args = set(kwargs.keys())

        message = GetDataTypesRequest()

        if len(unused_args) > 0:
            raise ArgumentError("get_data_types got unexpected keyword arguments '{}'".format("', '".join(unused_args)))
        return MessageWrapper(self._stub.get_data_types(message), unwraps=[])

    def get_signal_bytes(self, message=None, **kwargs):
        """
        Get signal data from the device.

        This can be used to sample the signal being produced by the device. The signal can be
        returned as raw ADC values or as calibrated picoamp (pA) values; see ``set_calibration`` on
        the device service for the values used in this conversion.

        In addition to the signal, this can return the associated channel configuration and/or bias
        voltage information, to help analyse the data.

        If bias voltage information is requested, one bias voltage sample will be provided for each
        signal sample (on any given channel). So if you request 20 samples of signal data and also
        bias voltages, you will get 20 signal samples on each channel and also 20 bias voltage
        samples. Bias voltages are always given in millivolts, and no corrections need to be applied
        (for example, the 5x amplifier on a MinION is already accounted for).

        If channel configuration information is requested, each channel will have the starting
        channel configuration (with offset 0 to indicate it applies to the first sample on that
        channel), as well as any configuration changes that affect any of the returned samples.

        If a device settings change RPC has completed before this method is called, the data returned
        is guaranteed to have been generated by the device after those settings were applied.
        However, note that no guarantee is made about how device settings changes that overlap with
        this request will affect the returned data.

        The response will be streamed. In order to limit the size of each response message, any given
        message may include data from only a subset of the requested channels.

        Note that the data is returned as bytes fields. See the GetSignalBytesResponse documentation
        for more details about how to interpret the value. In Python code, the minknow.Device class
        provides a convenience wrapper method to convert the data into numpy arrays.

        :param seconds:
            The amount of data to return in seconds.

            The number of samples returned will be just enough to cover this period of time. Cannot
            be specified at the same time as ``samples``.
        :param samples:
            The amount of data to return in samples.

            The result will contain exactly this many samples. If this is not possible, the call will
            fail. Cannot be specified at the same time as ``seconds``.
        :param first_channel: (required)
            The first channel (inclusive) to return data for.

            Note that channel numbering starts at 1.
        :param last_channel: (required)
            The last channel (inclusive) to return data for.

            Note that channel numbering starts at 1.
        :param include_channel_configs:
            Whether to include channel configuration settings.
        :param include_bias_voltages:
            Whether to include bias voltage information.
        :param calibrated_data:
            Whether the data should be calibrated.
        :rtype: GetSignalBytesResponse
        """
        if message is not None:
            return MessageWrapper(self._stub.get_signal_bytes(message), unwraps=[])

        unused_args = set(kwargs.keys())

        # check oneof group 'length'
        oneof_fields = set([
            'seconds',
            'samples',
        ])
        if len(unused_args & oneof_fields) > 1:
            raise ArgumentError("get_signal_bytes given multiple conflicting arguments: '{}'".format("', '".join(unused_args & oneof_fields)))
        message = GetSignalBytesRequest()

        if 'seconds' in kwargs:
            unused_args.remove('seconds')
            message.seconds = kwargs['seconds']

        if 'samples' in kwargs:
            unused_args.remove('samples')
            message.samples = kwargs['samples']

        if 'first_channel' in kwargs:
            unused_args.remove('first_channel')
            message.first_channel = kwargs['first_channel']
        else:
            raise ArgumentError("get_signal_bytes requires a 'first_channel' argument")

        if 'last_channel' in kwargs:
            unused_args.remove('last_channel')
            message.last_channel = kwargs['last_channel']
        else:
            raise ArgumentError("get_signal_bytes requires a 'last_channel' argument")

        if 'include_channel_configs' in kwargs:
            unused_args.remove('include_channel_configs')
            message.include_channel_configs = kwargs['include_channel_configs']

        if 'include_bias_voltages' in kwargs:
            unused_args.remove('include_bias_voltages')
            message.include_bias_voltages = kwargs['include_bias_voltages']

        if 'calibrated_data' in kwargs:
            unused_args.remove('calibrated_data')
            message.calibrated_data = kwargs['calibrated_data']

        if len(unused_args) > 0:
            raise ArgumentError("get_signal_bytes got unexpected keyword arguments '{}'".format("', '".join(unused_args)))
        return MessageWrapper(self._stub.get_signal_bytes(message), unwraps=[])

    def get_signal_min_max_bytes(self, message=None, **kwargs):
        """
        Get summarised signal data from the device.

        This provides signal data from the device, like get_signal_bytes, but instead of all the
        data, it divides the data up into windows, and provides the minimum and maximum values for
        each window.

        No bias voltage or channel configuration data is provided by this call.

        The response will be streamed. In order to limit the size of each response message, any given
        message may include data from only a subset of the requested channels.

        :param seconds:
            The amount of data to return in seconds.

            The number of samples returned will cover as much of this period of time as possible in
            complete windows.
        :param samples:
            The amount of data to return in samples.

            If this is not a multiple of window_size, it will be rounded down (a final partial window
            will not be provided). For example, if you request 25 samples with a window size of 10,
            you will only get 2 windows, covering 20 samples.
        :param first_channel: (required)
            The first channel (inclusive) to return data for.

            Note that channel numbering starts at 1.
        :param last_channel: (required)
            The last channel (inclusive) to return data for.

            Note that channel numbering starts at 1.
        :param window_size: (required)
            The size of window to summarise.

            A value of zero will be rejected; there is no default.
        :param calibrated_data:
            Whether the data should be calibrated.
        :rtype: GetSignalMinMaxBytesResponse
        """
        if message is not None:
            return MessageWrapper(self._stub.get_signal_min_max_bytes(message), unwraps=[])

        unused_args = set(kwargs.keys())

        # check oneof group 'length'
        oneof_fields = set([
            'seconds',
            'samples',
        ])
        if len(unused_args & oneof_fields) > 1:
            raise ArgumentError("get_signal_min_max_bytes given multiple conflicting arguments: '{}'".format("', '".join(unused_args & oneof_fields)))
        message = GetSignalMinMaxBytesRequest()

        if 'seconds' in kwargs:
            unused_args.remove('seconds')
            message.seconds = kwargs['seconds']

        if 'samples' in kwargs:
            unused_args.remove('samples')
            message.samples = kwargs['samples']

        if 'first_channel' in kwargs:
            unused_args.remove('first_channel')
            message.first_channel = kwargs['first_channel']
        else:
            raise ArgumentError("get_signal_min_max_bytes requires a 'first_channel' argument")

        if 'last_channel' in kwargs:
            unused_args.remove('last_channel')
            message.last_channel = kwargs['last_channel']
        else:
            raise ArgumentError("get_signal_min_max_bytes requires a 'last_channel' argument")

        if 'window_size' in kwargs:
            unused_args.remove('window_size')
            message.window_size = kwargs['window_size']
        else:
            raise ArgumentError("get_signal_min_max_bytes requires a 'window_size' argument")

        if 'calibrated_data' in kwargs:
            unused_args.remove('calibrated_data')
            message.calibrated_data = kwargs['calibrated_data']

        if len(unused_args) > 0:
            raise ArgumentError("get_signal_min_max_bytes got unexpected keyword arguments '{}'".format("', '".join(unused_args)))
        return MessageWrapper(self._stub.get_signal_min_max_bytes(message), unwraps=[])

    def get_live_reads(self, _iterator):
        return self._stub.get_live_reads(_iterator)


