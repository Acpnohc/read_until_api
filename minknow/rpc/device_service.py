### THIS FILE IS AUTOGENERATED. DO NOT EDIT THIS FILE DIRECTLY ###
from . import device_pb2_grpc
from . import device_pb2
from .device_pb2 import *
from .device_pb2_grpc import *
from minknow.rpc._support import MessageWrapper, ArgumentError

__all__ = [
    "DeviceService",
    "ChannelConfiguration",
    "GetDeviceInfoRequest",
    "GetDeviceInfoResponse",
    "GetFlowcellInfoRequest",
    "GetFlowcellInfoResponse",
    "SetCalibrationRequest",
    "SetCalibrationResponse",
    "ClearCalibrationRequest",
    "ClearCalibrationResponse",
    "ResetDeviceSettingsRequest",
    "ResetDeviceSettingsResponse",
    "GetCalibrationRequest",
    "GetCalibrationResponse",
    "SetTemperatureRequest",
    "SetTemperatureResponse",
    "GetTemperatureRequest",
    "GetTemperatureResponse",
    "SetUnblockModeRequest",
    "SetUnblockModeResponse",
    "GetUnblockModeRequest",
    "GetUnblockModeResponse",
    "GenericChannelConfig",
    "GetChannelConfigurationRequest",
    "GetChannelConfigurationResponse",
    "SetChannelConfigurationRequest",
    "SetChannelConfigurationResponse",
    "SetChannelConfigurationAllRequest",
    "SetChannelConfigurationAllResponse",
    "SaturationConfig",
    "SetSaturationConfigRequest",
    "SetSaturationConfigResponse",
    "GetSaturationConfigRequest",
    "GetSaturationConfigResponse",
    "GetSampleRateRequest",
    "GetSampleRateResponse",
    "SetSampleRateRequest",
    "SetSampleRateResponse",
    "GetBiasVoltageRequest",
    "GetBiasVoltageResponse",
    "SetBiasVoltageRequest",
    "SetBiasVoltageResponse",
    "UnblockMode",
    "UNBLOCK_MODE_REVERSE_BIAS",
    "UNBLOCK_MODE_REGEN_CURRENT_WITH_SWITCH_MUX",
    "UNBLOCK_MODE_REGEN_CURRENT_ONLY",
    "SelectedWell",
    "WELL_NONE",
    "WELL_1",
    "WELL_2",
    "WELL_3",
    "WELL_4",
    "WELL_OTHER",
]

class DeviceService(object):
    def __init__(self, channel):
        self._stub = DeviceServiceStub(channel)
        self._pb = device_pb2

    def get_device_info(self, message=None, **kwargs):
        """
        Get information about the device this MinKNOW instance was started for.

        In normal circumstances (ie: when using the manager service), a new MinKNOW instance
        is started for each available device. This call provides information about this device.

        The information returned by this call will not change (providing the MinKNOW instance
        was started by the manager service).

        :rtype: GetDeviceInfoResponse
        """
        if message is not None:
            return MessageWrapper(self._stub.get_device_info(message), unwraps=[])

        unused_args = set(kwargs.keys())

        message = GetDeviceInfoRequest()

        if len(unused_args) > 0:
            raise ArgumentError("get_device_info got unexpected keyword arguments '{}'".format("', '".join(unused_args)))
        return MessageWrapper(self._stub.get_device_info(message), unwraps=[])

    def reset_device_settings(self, message=None, **kwargs):
        """
        Reset all settings associate with the current device.

        This call will initialise all settings to their default state, ie the same as when MinKNOW boots.

        :rtype: ResetDeviceSettingsResponse
        """
        if message is not None:
            return MessageWrapper(self._stub.reset_device_settings(message), unwraps=[])

        unused_args = set(kwargs.keys())

        message = ResetDeviceSettingsRequest()

        if len(unused_args) > 0:
            raise ArgumentError("reset_device_settings got unexpected keyword arguments '{}'".format("', '".join(unused_args)))
        return MessageWrapper(self._stub.reset_device_settings(message), unwraps=[])

    def get_flowcell_info(self, message=None, **kwargs):
        """
        Get information about the flowcell (if any).

        This provides information about the flowcell attached to the device (described by
        get_device_info()), if any.

        :rtype: GetFlowcellInfoResponse
        """
        if message is not None:
            return MessageWrapper(self._stub.get_flowcell_info(message), unwraps=[])

        unused_args = set(kwargs.keys())

        message = GetFlowcellInfoRequest()

        if len(unused_args) > 0:
            raise ArgumentError("get_flowcell_info got unexpected keyword arguments '{}'".format("', '".join(unused_args)))
        return MessageWrapper(self._stub.get_flowcell_info(message), unwraps=[])

    def set_calibration(self, message=None, **kwargs):
        """
        Set the calibration measurements to be used by MinKNOW.

        Calibration describes how to convert from the raw ADC (analog-to-digital converter) values
        from the device into picoamps (pA).

        Note that calibration depends on the device, flowcell and some of the device settings
        (including sampling frequency and the capacitance used in the integratation circuit). If
        any of these are changed, the calibration will no longer be used. Instead, a previously-saved
        calibration (for that combination of flowcell and settings) might be used, or the identity
        calibration might be used.

        On a MinION, the settings that a calibration depends on are sampling frequency and
        integration capacitor.

        :param first_channel: (required)
            The first channel included in calibration data.

            This must always be 1. This is required in order to make sure the client and MinKNOW agree on
            what data is being provided.
        :param last_channel: (required)
            The last channel included in calibration data.

            This must always be the same as the channel count returned by
            :meth:`get_flowcell_info`. This is required in order to make
            sure the client and MinKNOW agree on what data is being provided.
        :param offsets: (required)
            The ADC value adjustment to reach 0pA on each channel.

            This is ``-x``, where ``x`` is the (mean) ADC value at 0pA.
        :param pa_ranges: (required)
            The range of possible pA values that can be produced by the device.
        :rtype: SetCalibrationResponse
        """
        if message is not None:
            return MessageWrapper(self._stub.set_calibration(message), unwraps=[])

        unused_args = set(kwargs.keys())

        message = SetCalibrationRequest()

        if 'first_channel' in kwargs:
            unused_args.remove('first_channel')
            message.first_channel = kwargs['first_channel']
        else:
            raise ArgumentError("set_calibration requires a 'first_channel' argument")

        if 'last_channel' in kwargs:
            unused_args.remove('last_channel')
            message.last_channel = kwargs['last_channel']
        else:
            raise ArgumentError("set_calibration requires a 'last_channel' argument")

        if 'offsets' in kwargs:
            unused_args.remove('offsets')
            message.offsets.extend(kwargs['offsets'])
        else:
            raise ArgumentError("set_calibration requires a 'offsets' argument")

        if 'pa_ranges' in kwargs:
            unused_args.remove('pa_ranges')
            message.pa_ranges.extend(kwargs['pa_ranges'])
        else:
            raise ArgumentError("set_calibration requires a 'pa_ranges' argument")

        if len(unused_args) > 0:
            raise ArgumentError("set_calibration got unexpected keyword arguments '{}'".format("', '".join(unused_args)))
        return MessageWrapper(self._stub.set_calibration(message), unwraps=[])

    def clear_calibration(self, message=None, **kwargs):
        """
        Clear the current calibration.

        This is the same as setting the calibration to be the identity function (setting all offsets
        to 0, and all pA ranges to the digitisation value).

        :rtype: ClearCalibrationResponse
        """
        if message is not None:
            return MessageWrapper(self._stub.clear_calibration(message), unwraps=[])

        unused_args = set(kwargs.keys())

        message = ClearCalibrationRequest()

        if len(unused_args) > 0:
            raise ArgumentError("clear_calibration got unexpected keyword arguments '{}'".format("', '".join(unused_args)))
        return MessageWrapper(self._stub.clear_calibration(message), unwraps=[])

    def get_calibration(self, message=None, **kwargs):
        """
        The calibration measurements being used by MinKNOW.

        Calibration describes how to convert from the raw ADC (analog-to-digital converter) values
        from the device into picoamps (pA).

        To get a pA value from an ADC value the following function is applied::

             pA_current = (adc_current + offset) / (digitisation / pA_range)

        The digitisation is the range of possible ADC values. It is the same for all channels.

        If there is no calibration (including if it was cleared with ``clear_calibration()`` or
        invalidated because of device settings changes), this will return the identity calibration:
        all offsets will be 0, and the pA ranges will be the same as the digitisation.

        :param first_channel: (required)
            The first channel to get calibration data for.

            This should normally be 1.
        :param last_channel: (required)
            The last channel included in calibration data.

            This should normally be the channel count returned by
            :meth:`get_flowcell_info`.
        :rtype: GetCalibrationResponse
        """
        if message is not None:
            return MessageWrapper(self._stub.get_calibration(message), unwraps=[])

        unused_args = set(kwargs.keys())

        message = GetCalibrationRequest()

        if 'first_channel' in kwargs:
            unused_args.remove('first_channel')
            message.first_channel = kwargs['first_channel']
        else:
            raise ArgumentError("get_calibration requires a 'first_channel' argument")

        if 'last_channel' in kwargs:
            unused_args.remove('last_channel')
            message.last_channel = kwargs['last_channel']
        else:
            raise ArgumentError("get_calibration requires a 'last_channel' argument")

        if len(unused_args) > 0:
            raise ArgumentError("get_calibration got unexpected keyword arguments '{}'".format("', '".join(unused_args)))
        return MessageWrapper(self._stub.get_calibration(message), unwraps=[])

    def set_temperature(self, message=None, **kwargs):
        """
        If the device is capable (see GetDeviceInfoResponse.temperature_controllable)
        then this sets the minimum and maximum temperatures of the flow-cell.

        :param temperature:
            The desired temperature in degrees Celsius.

            If temperature control is supported and enabled, the device will attempt to keep its
            temperature at this value. See the ``can_set_temperature`` field returned by the
            DeviceService.get_device_info() RPC.
        :rtype: SetTemperatureResponse
        """
        if message is not None:
            return MessageWrapper(self._stub.set_temperature(message), unwraps=[])

        unused_args = set(kwargs.keys())

        message = SetTemperatureRequest()

        if 'temperature' in kwargs:
            unused_args.remove('temperature')
            message.temperature = kwargs['temperature']

        if len(unused_args) > 0:
            raise ArgumentError("set_temperature got unexpected keyword arguments '{}'".format("', '".join(unused_args)))
        return MessageWrapper(self._stub.set_temperature(message), unwraps=[])

    def get_temperature(self, message=None, **kwargs):
        """
        Get the current temperature of the device.

        Since 1.11

        :rtype: GetTemperatureResponse
        """
        if message is not None:
            return MessageWrapper(self._stub.get_temperature(message), unwraps=[])

        unused_args = set(kwargs.keys())

        message = GetTemperatureRequest()

        if len(unused_args) > 0:
            raise ArgumentError("get_temperature got unexpected keyword arguments '{}'".format("', '".join(unused_args)))
        return MessageWrapper(self._stub.get_temperature(message), unwraps=[])

    def set_unblock_mode(self, message=None, **kwargs):
        """
        Set the unblock mode to one of:

        REVERSE_BIAS_UNBLOCK - MinION only, applies the unblock voltage
        REGEN_CURRENT_WITH_SWITCH_MUX - PromethION only. Applies regeneration current and sets the regen pore
            to the original well, while disconnecting the well. Disables hardware saturation during the unblock.
            After the unblock time it restores the original state.
        REGEN_CURRENT_ONLY - PromethION only. Applies regeneration current while leaving the mux connected.
            Disables hardware saturation meanwhile. After the unblock time it restores the original state.
        This should be called while the experiment is not running, though the system will perform the unblock
        even if the unblock type has changed during the experiment, but the behaviour of the unblock will change.

        :param unblock_mode:
            The unblock mode to set

        :rtype: SetUnblockModeResponse
        """
        if message is not None:
            return MessageWrapper(self._stub.set_unblock_mode(message), unwraps=[])

        unused_args = set(kwargs.keys())

        message = SetUnblockModeRequest()

        if 'unblock_mode' in kwargs:
            unused_args.remove('unblock_mode')
            message.unblock_mode = kwargs['unblock_mode']

        if len(unused_args) > 0:
            raise ArgumentError("set_unblock_mode got unexpected keyword arguments '{}'".format("', '".join(unused_args)))
        return MessageWrapper(self._stub.set_unblock_mode(message), unwraps=[])

    def get_unblock_mode(self, message=None, **kwargs):
        """
        Get the unblock mode.

        :rtype: GetUnblockModeResponse
        """
        if message is not None:
            return MessageWrapper(self._stub.get_unblock_mode(message), unwraps=[])

        unused_args = set(kwargs.keys())

        message = GetUnblockModeRequest()

        if len(unused_args) > 0:
            raise ArgumentError("get_unblock_mode got unexpected keyword arguments '{}'".format("', '".join(unused_args)))
        return MessageWrapper(self._stub.get_unblock_mode(message), unwraps=[])

    def get_channel_configuration(self, message=None, **kwargs):
        """
        Get the channel configuration for any number of channels

        The maximum addressable channel will depend on the device. Currently this will be 512 on a MinION/GridION
        and 4096 on a PromethION

        :param channels:
            A list of channel names (1-indexed) to specify what channels to get channel configs for

            Will return an error if any of the channel names are below 1, or above the channel count value
            returned from :meth:`get_flowcell_info`
        :rtype: GetChannelConfigurationResponse
        """
        if message is not None:
            return MessageWrapper(self._stub.get_channel_configuration(message), unwraps=[])

        unused_args = set(kwargs.keys())

        message = GetChannelConfigurationRequest()

        if 'channels' in kwargs:
            unused_args.remove('channels')
            message.channels.extend(kwargs['channels'])

        if len(unused_args) > 0:
            raise ArgumentError("get_channel_configuration got unexpected keyword arguments '{}'".format("', '".join(unused_args)))
        return MessageWrapper(self._stub.get_channel_configuration(message), unwraps=[])

    def set_channel_configuration(self, message=None, **kwargs):
        """
        Set the channel configuration for any number of channels

        The maximum addressable channel will depend on the device. Currently this will be 512 on a MinION/GridION
        and 4096 on a PromethION.

        :param channel_configurations:
            A map between <channel name, config to set>

            Will return an error if any of the key values (representing channel names) are below 1, or 
            above the channel count value returned from :meth:`get_flowcell_info`

            The selected well cannot be set to WELL_OTHER, and will error if it tries to do so
        :rtype: SetChannelConfigurationResponse
        """
        if message is not None:
            return MessageWrapper(self._stub.set_channel_configuration(message), unwraps=[])

        unused_args = set(kwargs.keys())

        message = SetChannelConfigurationRequest()

        if 'channel_configurations' in kwargs:
            unused_args.remove('channel_configurations')
            for key, value in kwargs['channel_configurations'].items():
                message.channel_configurations[key].CopyFrom(value)

        if len(unused_args) > 0:
            raise ArgumentError("set_channel_configuration got unexpected keyword arguments '{}'".format("', '".join(unused_args)))
        return MessageWrapper(self._stub.set_channel_configuration(message), unwraps=[])

    def set_channel_configuration_all(self, message=None, **kwargs):
        """

        :param selected_well:
        :param test_current:
        :param regen_current:
        :param reverse_bias:
        :rtype: SetChannelConfigurationAllResponse
        """
        if message is not None:
            return MessageWrapper(self._stub.set_channel_configuration_all(message), unwraps=[])

        unused_args = set(kwargs.keys())

        message = SetChannelConfigurationAllRequest()

        if 'selected_well' in kwargs:
            unused_args.remove('selected_well')
            message.channel_configuration.selected_well = kwargs['selected_well']

        if 'test_current' in kwargs:
            unused_args.remove('test_current')
            message.channel_configuration.test_current = kwargs['test_current']

        if 'regen_current' in kwargs:
            unused_args.remove('regen_current')
            message.channel_configuration.regen_current = kwargs['regen_current']

        if 'reverse_bias' in kwargs:
            unused_args.remove('reverse_bias')
            message.channel_configuration.reverse_bias = kwargs['reverse_bias']

        if len(unused_args) > 0:
            raise ArgumentError("set_channel_configuration_all got unexpected keyword arguments '{}'".format("', '".join(unused_args)))
        return MessageWrapper(self._stub.set_channel_configuration_all(message), unwraps=[])

    def set_saturation_config(self, message=None, **kwargs):
        """
        Set the saturation control configuration.

        The request is immediately sent to the data acquisition module, and applied. All settings can be changed
        whilst the experiment is running.

        If any keys are not specified when this method is called (see the message for specific optional parameters),
        the previously applied parameters are kept; initially, when this method has never been called, defaults from the
        application config are used.

        note: calling this method resets anu in-progress saturations when it is called, causing them to need to start
        saturation counts again, this may mean any saturations may take longer to occur.

        :param thresholds:
            Settings for saturation count thresholds, this controls how long a
            saturated value must be over limit before the channel is turned off.

            If not specified, the previous thresholds are kept.
        :param software_saturation:
            Settings for software saturation, specified in adc units of the device.

            If not specified, the previous thresholds are kept.
        :param user_threshold_saturation:
            Settings for user threshold saturation, specified in pA.

            If not specified, the previous thresholds are kept.
        :rtype: SetSaturationConfigResponse
        """
        if message is not None:
            return MessageWrapper(self._stub.set_saturation_config(message), unwraps=[])

        unused_args = set(kwargs.keys())

        message = SetSaturationConfigRequest()

        if 'thresholds' in kwargs:
            unused_args.remove('thresholds')
            message.settings.thresholds.CopyFrom(kwargs['thresholds'])

        if 'software_saturation' in kwargs:
            unused_args.remove('software_saturation')
            message.settings.software_saturation.CopyFrom(kwargs['software_saturation'])

        if 'user_threshold_saturation' in kwargs:
            unused_args.remove('user_threshold_saturation')
            message.settings.user_threshold_saturation.CopyFrom(kwargs['user_threshold_saturation'])

        if len(unused_args) > 0:
            raise ArgumentError("set_saturation_config got unexpected keyword arguments '{}'".format("', '".join(unused_args)))
        return MessageWrapper(self._stub.set_saturation_config(message), unwraps=[])

    def get_saturation_config(self, message=None, **kwargs):
        """
        Get the saturation control configuration.

        The default configuration is specifed by the MinKNOW application configuration, the command returns the most
        recently applied saturation config.

        :rtype: GetSaturationConfigResponse
        """
        if message is not None:
            return MessageWrapper(self._stub.get_saturation_config(message), unwraps=["settings"])

        unused_args = set(kwargs.keys())

        message = GetSaturationConfigRequest()

        if len(unused_args) > 0:
            raise ArgumentError("get_saturation_config got unexpected keyword arguments '{}'".format("', '".join(unused_args)))
        return MessageWrapper(self._stub.get_saturation_config(message), unwraps=["settings"])

    def get_sample_rate(self, message=None, **kwargs):
        """
        Get the sample rate of the device

        Please refer to MinionDeviceService and PromethionDeviceService for the expected
        return value for a minion and promethion respectively

        :rtype: GetSampleRateResponse
        """
        if message is not None:
            return MessageWrapper(self._stub.get_sample_rate(message), unwraps=[])

        unused_args = set(kwargs.keys())

        message = GetSampleRateRequest()

        if len(unused_args) > 0:
            raise ArgumentError("get_sample_rate got unexpected keyword arguments '{}'".format("', '".join(unused_args)))
        return MessageWrapper(self._stub.get_sample_rate(message), unwraps=[])

    def set_sample_rate(self, message=None, **kwargs):
        """
        Set the sample rate of the device, and returns the actual value set on the device

        Please refer to MinionDeviceService and PromethionDeviceService to see
        how the value set here will be used to determine the real sample rate for a
        minion and promethion respectively

        Trying to set the sample rate during an acquisition period will result in an error

        :param sample_rate: (required)
        :rtype: SetSampleRateResponse
        """
        if message is not None:
            return MessageWrapper(self._stub.set_sample_rate(message), unwraps=[])

        unused_args = set(kwargs.keys())

        message = SetSampleRateRequest()

        if 'sample_rate' in kwargs:
            unused_args.remove('sample_rate')
            message.sample_rate = kwargs['sample_rate']
        else:
            raise ArgumentError("set_sample_rate requires a 'sample_rate' argument")

        if len(unused_args) > 0:
            raise ArgumentError("set_sample_rate got unexpected keyword arguments '{}'".format("', '".join(unused_args)))
        return MessageWrapper(self._stub.set_sample_rate(message), unwraps=[])

    def get_bias_voltage(self, message=None, **kwargs):
        """

        :rtype: GetBiasVoltageResponse
        """
        if message is not None:
            return MessageWrapper(self._stub.get_bias_voltage(message), unwraps=[])

        unused_args = set(kwargs.keys())

        message = GetBiasVoltageRequest()

        if len(unused_args) > 0:
            raise ArgumentError("get_bias_voltage got unexpected keyword arguments '{}'".format("', '".join(unused_args)))
        return MessageWrapper(self._stub.get_bias_voltage(message), unwraps=[])

    def set_bias_voltage(self, message=None, **kwargs):
        """

        :param bias_voltage: (required)
        :rtype: SetBiasVoltageResponse
        """
        if message is not None:
            return MessageWrapper(self._stub.set_bias_voltage(message), unwraps=[])

        unused_args = set(kwargs.keys())

        message = SetBiasVoltageRequest()

        if 'bias_voltage' in kwargs:
            unused_args.remove('bias_voltage')
            message.bias_voltage = kwargs['bias_voltage']
        else:
            raise ArgumentError("set_bias_voltage requires a 'bias_voltage' argument")

        if len(unused_args) > 0:
            raise ArgumentError("set_bias_voltage got unexpected keyword arguments '{}'".format("', '".join(unused_args)))
        return MessageWrapper(self._stub.set_bias_voltage(message), unwraps=[])


