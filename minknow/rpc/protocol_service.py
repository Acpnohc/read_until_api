### THIS FILE IS AUTOGENERATED. DO NOT EDIT THIS FILE DIRECTLY ###
from . import protocol_pb2_grpc
from . import protocol_pb2
from .protocol_pb2 import *
from .protocol_pb2_grpc import *
from minknow.rpc._support import MessageWrapper, ArgumentError

__all__ = [
    "ProtocolService",
    "ProtocolRunUserInfo",
    "StartProtocolRequest",
    "StartProtocolResponse",
    "StopProtocolRequest",
    "StopProtocolResponse",
    "ListProtocolsRequest",
    "ProtocolInfo",
    "ListProtocolsResponse",
    "WaitForFinishedRequest",
    "GetRunInfoRequest",
    "ProtocolRunInfo",
    "ListProtocolRunsRequest",
    "ListProtocolRunsResponse",
    "GetProtocolInfoRequest",
    "GetProtocolInfoResponse",
    "GetContextInfoRequest",
    "GetContextInfoResponse",
    "SetContextInfoRequest",
    "SetContextInfoResponse",
    "GetSampleIdRequest",
    "GetSampleIdResponse",
    "SetSampleIdRequest",
    "SetSampleIdResponse",
    "GetProtocolPurposeRequest",
    "GetProtocolPurposeResponse",
    "SetProtocolPurposeRequest",
    "SetProtocolPurposeResponse",
    "ProtocolState",
    "PROTOCOL_RUNNING",
    "PROTOCOL_COMPLETED",
    "PROTOCOL_STOPPED_BY_USER",
    "PROTOCOL_FINISHED_WITH_ERROR",
]

class ProtocolService(object):
    def __init__(self, channel):
        self._stub = ProtocolServiceStub(channel)
        self._pb = protocol_pb2

    def start_protocol(self, message=None, **kwargs):
        """
        Initiates a python instance that runs the script specified by the `path` argument.
        `list_protocols` will give back a list of protocol scripts that can be started by this call

        :param identifier: (required)
            The identifier of the protocol, as provided by list_protocols().
        :param args:
            The arguments to pass to the protocol.
        :param user_info:
            User input describing the protocol.
        :rtype: StartProtocolResponse
        """
        if message is not None:
            return MessageWrapper(self._stub.start_protocol(message), unwraps=[])

        unused_args = set(kwargs.keys())

        message = StartProtocolRequest()

        if 'identifier' in kwargs:
            unused_args.remove('identifier')
            message.identifier = kwargs['identifier']
        else:
            raise ArgumentError("start_protocol requires a 'identifier' argument")

        if 'args' in kwargs:
            unused_args.remove('args')
            message.args.extend(kwargs['args'])

        if 'user_info' in kwargs:
            unused_args.remove('user_info')
            message.user_info.CopyFrom(kwargs['user_info'])

        if len(unused_args) > 0:
            raise ArgumentError("start_protocol got unexpected keyword arguments '{}'".format("', '".join(unused_args)))
        return MessageWrapper(self._stub.start_protocol(message), unwraps=[])

    def stop_protocol(self, message=None, **kwargs):
        """
        Stops the currently running protocol script instance

        :rtype: StopProtocolResponse
        """
        if message is not None:
            return MessageWrapper(self._stub.stop_protocol(message), unwraps=[])

        unused_args = set(kwargs.keys())

        message = StopProtocolRequest()

        if len(unused_args) > 0:
            raise ArgumentError("stop_protocol got unexpected keyword arguments '{}'".format("', '".join(unused_args)))
        return MessageWrapper(self._stub.stop_protocol(message), unwraps=[])

    def wait_for_finished(self, message=None, **kwargs):
        """
        Wait for a protocol run to finish.

        The call blocks until the run with the given run ID has finished (or returns immediately if
        it had already finished) and returns information about the protocol run.

        If no run has been started with the provided run ID (or no run ID is given), an error is
        returned.

        Since 1.10

        :param run_id: (required)
            Only consider a specific protocol run.
        :rtype: ProtocolRunInfo
        """
        if message is not None:
            return MessageWrapper(self._stub.wait_for_finished(message), unwraps=[])

        unused_args = set(kwargs.keys())

        message = WaitForFinishedRequest()

        if 'run_id' in kwargs:
            unused_args.remove('run_id')
            message.run_id = kwargs['run_id']
        else:
            raise ArgumentError("wait_for_finished requires a 'run_id' argument")

        if len(unused_args) > 0:
            raise ArgumentError("wait_for_finished got unexpected keyword arguments '{}'".format("', '".join(unused_args)))
        return MessageWrapper(self._stub.wait_for_finished(message), unwraps=[])

    def get_run_info(self, message=None, **kwargs):
        """
        Gets information about a protocol run.

        If no run ID is provided, information about the most recently started protocol run is
        provided.

        Since 1.10

        :param run_id:
            The protocol run to get information about.
        :rtype: ProtocolRunInfo
        """
        if message is not None:
            return MessageWrapper(self._stub.get_run_info(message), unwraps=[])

        unused_args = set(kwargs.keys())

        message = GetRunInfoRequest()

        if 'run_id' in kwargs:
            unused_args.remove('run_id')
            message.run_id = kwargs['run_id']

        if len(unused_args) > 0:
            raise ArgumentError("get_run_info got unexpected keyword arguments '{}'".format("', '".join(unused_args)))
        return MessageWrapper(self._stub.get_run_info(message), unwraps=[])

    def list_protocol_runs(self, message=None, **kwargs):
        """
        List previously started protocol run ids (including any current protocol), in order of starting.

        The returned object can be used to find protocol information with get_run_info.

        Since 1.11

        :rtype: ListProtocolRunsResponse
        """
        if message is not None:
            return MessageWrapper(self._stub.list_protocol_runs(message), unwraps=[])

        unused_args = set(kwargs.keys())

        message = ListProtocolRunsRequest()

        if len(unused_args) > 0:
            raise ArgumentError("list_protocol_runs got unexpected keyword arguments '{}'".format("', '".join(unused_args)))
        return MessageWrapper(self._stub.list_protocol_runs(message), unwraps=[])

    def list_protocols(self, message=None, **kwargs):
        """
        Gives back a list that contains info about each possible protocol script minknow is aware of.
        This will most likely be used to retrieve a suitable protocol script that can be passed on to `start_protocol`

        Since 1.10

        :rtype: ListProtocolsResponse
        """
        if message is not None:
            return MessageWrapper(self._stub.list_protocols(message), unwraps=[])

        unused_args = set(kwargs.keys())

        message = ListProtocolsRequest()

        if len(unused_args) > 0:
            raise ArgumentError("list_protocols got unexpected keyword arguments '{}'".format("', '".join(unused_args)))
        return MessageWrapper(self._stub.list_protocols(message), unwraps=[])

    def get_protocol_info(self, message=None, **kwargs):
        """
        Returns the name and run id of the currently running protocol.

        Will fail with FAILED_PRECONDITION if there is no protocol running

        Since 1.11

        :rtype: GetProtocolInfoResponse
        """
        if message is not None:
            return MessageWrapper(self._stub.get_protocol_info(message), unwraps=[])

        unused_args = set(kwargs.keys())

        message = GetProtocolInfoRequest()

        if len(unused_args) > 0:
            raise ArgumentError("get_protocol_info got unexpected keyword arguments '{}'".format("', '".join(unused_args)))
        return MessageWrapper(self._stub.get_protocol_info(message), unwraps=[])

    def get_context_info(self, message=None, **kwargs):
        """
        Returns string-to-string map of the context tags

        Since 1.11

        :rtype: GetContextInfoResponse
        """
        if message is not None:
            return MessageWrapper(self._stub.get_context_info(message), unwraps=[])

        unused_args = set(kwargs.keys())

        message = GetContextInfoRequest()

        if len(unused_args) > 0:
            raise ArgumentError("get_context_info got unexpected keyword arguments '{}'".format("', '".join(unused_args)))
        return MessageWrapper(self._stub.get_context_info(message), unwraps=[])

    def set_context_info(self, message=None, **kwargs):
        """
        Store context tags as arbitary string-to-string map

        Since 1.11

        :param context_info:
        :rtype: SetContextInfoResponse
        """
        if message is not None:
            return MessageWrapper(self._stub.set_context_info(message), unwraps=[])

        unused_args = set(kwargs.keys())

        message = SetContextInfoRequest()

        if 'context_info' in kwargs:
            unused_args.remove('context_info')
            message.context_info.update(kwargs['context_info'])

        if len(unused_args) > 0:
            raise ArgumentError("set_context_info got unexpected keyword arguments '{}'".format("', '".join(unused_args)))
        return MessageWrapper(self._stub.set_context_info(message), unwraps=[])

    def get_sample_id(self, message=None, **kwargs):
        """
        Sample id is a value set from the GUI that is defined by the user to identify an experiment.
        This call gets this value

        Since 1.11

        :rtype: GetSampleIdResponse
        """
        if message is not None:
            return MessageWrapper(self._stub.get_sample_id(message), unwraps=[])

        unused_args = set(kwargs.keys())

        message = GetSampleIdRequest()

        if len(unused_args) > 0:
            raise ArgumentError("get_sample_id got unexpected keyword arguments '{}'".format("', '".join(unused_args)))
        return MessageWrapper(self._stub.get_sample_id(message), unwraps=[])

    def set_sample_id(self, message=None, **kwargs):
        """
        Sets the sample id. Refer to get_sample_id for what sample id is used for

        Since 1.11

        :param sample_id:
        :rtype: SetSampleIdResponse
        """
        if message is not None:
            return MessageWrapper(self._stub.set_sample_id(message), unwraps=[])

        unused_args = set(kwargs.keys())

        message = SetSampleIdRequest()

        if 'sample_id' in kwargs:
            unused_args.remove('sample_id')
            message.sample_id = kwargs['sample_id']

        if len(unused_args) > 0:
            raise ArgumentError("set_sample_id got unexpected keyword arguments '{}'".format("', '".join(unused_args)))
        return MessageWrapper(self._stub.set_sample_id(message), unwraps=[])

    def get_protocol_purpose(self, message=None, **kwargs):
        """
        Value set by protocol scripts to define the purpose of the script. Gets this value

        Since 1.11

        :rtype: GetProtocolPurposeResponse
        """
        if message is not None:
            return MessageWrapper(self._stub.get_protocol_purpose(message), unwraps=[])

        unused_args = set(kwargs.keys())

        message = GetProtocolPurposeRequest()

        if len(unused_args) > 0:
            raise ArgumentError("get_protocol_purpose got unexpected keyword arguments '{}'".format("', '".join(unused_args)))
        return MessageWrapper(self._stub.get_protocol_purpose(message), unwraps=[])

    def set_protocol_purpose(self, message=None, **kwargs):
        """
        Sets the protocol purpose. See also get_protocol_purpose

        Since 1.11

        :param purpose:
        :rtype: SetProtocolPurposeResponse
        """
        if message is not None:
            return MessageWrapper(self._stub.set_protocol_purpose(message), unwraps=[])

        unused_args = set(kwargs.keys())

        message = SetProtocolPurposeRequest()

        if 'purpose' in kwargs:
            unused_args.remove('purpose')
            message.purpose = kwargs['purpose']

        if len(unused_args) > 0:
            raise ArgumentError("set_protocol_purpose got unexpected keyword arguments '{}'".format("', '".join(unused_args)))
        return MessageWrapper(self._stub.set_protocol_purpose(message), unwraps=[])


