### THIS FILE IS AUTOGENERATED. DO NOT EDIT THIS FILE DIRECTLY ###
from . import acquisition_pb2_grpc
from . import acquisition_pb2
from .acquisition_pb2 import *
from .acquisition_pb2_grpc import *
from minknow.rpc._support import MessageWrapper, ArgumentError

__all__ = [
    "AcquisitionService",
    "StartRequest",
    "StartResponse",
    "StopRequest",
    "StopResponse",
    "WatchForStatusChangeRequest",
    "WatchForStatusChangeResponse",
    "CurrentStatusRequest",
    "CurrentStatusResponse",
    "GetProgressRequest",
    "GetProgressResponse",
    "GetAcquisitionRunInfoRequest",
    "AcquisitionRunInfo",
    "ListAcquisitionRunsRequest",
    "ListAcquisitionRunsResponse",
    "MinknowStatus",
    "ERROR_STATUS",
    "READY",
    "STARTING",
    "PROCESSING",
    "FINISHING",
    "AcquisitionState",
    "ACQUISITION_STARTING",
    "ACQUISITION_RUNNING",
    "ACQUISITION_FINISHING",
    "ACQUISITION_COMPLETED",
    "AcquisitionStopReason",
    "STOPPED_NOT_SET",
    "STOPPED_USER_REQUESTED",
    "STOPPED_NO_DISK_SPACE",
    "STOPPED_DEVICE_STOPPED_ACQUISITION",
    "STOPPED_STARTING_ANOTHER_RUN",
    "STOPPED_PROTOCOL_ENDED",
    "STOPPED_DEVICE_ERROR",
]

class AcquisitionService(object):
    def __init__(self, channel):
        self._stub = AcquisitionServiceStub(channel)
        self._pb = acquisition_pb2

    def start(self, message=None, **kwargs):
        """
        Starts reading data from the device

        Some setup calls will need to be made before starting data acquisition: particularly setting the analysis configuration, 
        calibration, read writer and bulk writer config and some device calls such as setting the sampling frequency

        note: A run cannot be started if MinKNOW is already running.

        :param wait_until_processing:
            Defaults to false.
            If false will return as soon as minknow enters the STARTING state.
            If true then returns as soon as minknow enters the PROCESSING state.
        :rtype: StartResponse
        """
        if message is not None:
            return MessageWrapper(self._stub.start(message), unwraps=[])

        unused_args = set(kwargs.keys())

        message = StartRequest()

        if 'wait_until_processing' in kwargs:
            unused_args.remove('wait_until_processing')
            message.wait_until_processing = kwargs['wait_until_processing']

        if len(unused_args) > 0:
            raise ArgumentError("start got unexpected keyword arguments '{}'".format("', '".join(unused_args)))
        return MessageWrapper(self._stub.start(message), unwraps=[])

    def stop(self, message=None, **kwargs):
        """
        Stops data acquisition.

        Can specify a stop mode that handles what is done with the data when data acquisition is stopped. Refer to the enum
        description for documentation on what each mode does.

        Be aware that this command will return as soon as Minknow enters the FINISHING state and not the READY state.
        So if starting a new experiment then you will have to wait for the READY state seperately

        :param data_action_on_stop:
        :param wait_until_ready:
            Defaults to false
            If false will return as soon as minknow enters the FINISHING state.
            If true then returns as soon as minknow enters the READY state.
        :rtype: StopResponse
        """
        if message is not None:
            return MessageWrapper(self._stub.stop(message), unwraps=[])

        unused_args = set(kwargs.keys())

        message = StopRequest()

        if 'data_action_on_stop' in kwargs:
            unused_args.remove('data_action_on_stop')
            message.data_action_on_stop = kwargs['data_action_on_stop']

        if 'wait_until_ready' in kwargs:
            unused_args.remove('wait_until_ready')
            message.wait_until_ready = kwargs['wait_until_ready']

        if len(unused_args) > 0:
            raise ArgumentError("stop got unexpected keyword arguments '{}'".format("', '".join(unused_args)))
        return MessageWrapper(self._stub.stop(message), unwraps=[])

    def watch_for_status_change(self, _iterator):
        return self._stub.watch_for_status_change(_iterator)

    def current_status(self, message=None, **kwargs):
        """
        Check the current status of MinKNOW.

        :rtype: CurrentStatusResponse
        """
        if message is not None:
            return MessageWrapper(self._stub.current_status(message), unwraps=[])

        unused_args = set(kwargs.keys())

        message = CurrentStatusRequest()

        if len(unused_args) > 0:
            raise ArgumentError("current_status got unexpected keyword arguments '{}'".format("', '".join(unused_args)))
        return MessageWrapper(self._stub.current_status(message), unwraps=[])

    def get_progress(self, message=None, **kwargs):
        """
        Information on how much data has been acquired, processed and written.

        :rtype: GetProgressResponse
        """
        if message is not None:
            return MessageWrapper(self._stub.get_progress(message), unwraps=[])

        unused_args = set(kwargs.keys())

        message = GetProgressRequest()

        if len(unused_args) > 0:
            raise ArgumentError("get_progress got unexpected keyword arguments '{}'".format("', '".join(unused_args)))
        return MessageWrapper(self._stub.get_progress(message), unwraps=[])

    def get_acquisition_info(self, message=None, **kwargs):
        """
        Gets information about an acquisition run, run within this instance on MinKNOW.

        If no run ID is provided, information about the most recently started acquisition run is
        provided.

        Since 1.11

        :param run_id:
            The protocol run to get information about.
        :rtype: AcquisitionRunInfo
        """
        if message is not None:
            return MessageWrapper(self._stub.get_acquisition_info(message), unwraps=[])

        unused_args = set(kwargs.keys())

        message = GetAcquisitionRunInfoRequest()

        if 'run_id' in kwargs:
            unused_args.remove('run_id')
            message.run_id = kwargs['run_id']

        if len(unused_args) > 0:
            raise ArgumentError("get_acquisition_info got unexpected keyword arguments '{}'".format("', '".join(unused_args)))
        return MessageWrapper(self._stub.get_acquisition_info(message), unwraps=[])

    def list_acquisition_runs(self, message=None, **kwargs):
        """
        Gets information about all previous protocol runs.

        Since 1.11

        :rtype: ListAcquisitionRunsResponse
        """
        if message is not None:
            return MessageWrapper(self._stub.list_acquisition_runs(message), unwraps=[])

        unused_args = set(kwargs.keys())

        message = ListAcquisitionRunsRequest()

        if len(unused_args) > 0:
            raise ArgumentError("list_acquisition_runs got unexpected keyword arguments '{}'".format("', '".join(unused_args)))
        return MessageWrapper(self._stub.list_acquisition_runs(message), unwraps=[])


